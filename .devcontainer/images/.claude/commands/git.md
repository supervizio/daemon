# Git - Workflow Git Automation

$ARGUMENTS

---

## Description

Commande unifiée pour les opérations Git :
- **--commit** : Workflow complet (branch, commit, push, PR)
- **--merge** : Merge avec CI validation et auto-fix

---

## Arguments

| Pattern | Action |
|---------|--------|
| `--commit` | Workflow complet : branch, commit, push, PR |
| `--merge` | Merge la PR avec CI validation |
| `--help` | Affiche l'aide |

### Options --commit

| Option | Action |
|--------|--------|
| `--branch <nom>` | Force le nom de branche |
| `--no-pr` | Skip la création de PR |
| `--amend` | Amend le dernier commit |
| `--rename <nom>` | Renomme la branche avant push/PR |

### Options --merge

| Option | Action |
|--------|--------|
| `--pr <number>` | Merge une PR spécifique |
| `--strategy <type>` | Méthode: merge/squash/rebase (défaut: squash) |
| `--no-delete` | Ne pas supprimer la branche après merge |
| `--dry-run` | Vérifier sans merger |

---

## --help

Quand `--help` est passé, afficher :

```
═══════════════════════════════════════════════
  /git - Workflow Git Automation
═══════════════════════════════════════════════

Usage: /git <action> [options]

Actions:
  --commit          Workflow complet (branch, commit, push, PR)
  --merge           Merge avec CI validation et auto-fix

Options --commit:
  --branch <nom>    Force le nom de branche
  --no-pr           Skip la création de PR
  --amend           Amend le dernier commit
  --rename <nom>    Renomme la branche avant push/PR

Options --merge:
  --pr <number>     Merge une PR spécifique
  --strategy <type> Méthode: merge/squash/rebase (défaut: squash)
  --no-delete       Garder la branche après merge
  --dry-run         Vérifier sans merger

Exemples:
  /git --commit                 Commit + PR automatique
  /git --commit --no-pr         Commit sans créer de PR
  /git --merge                  Merge la PR courante
  /git --merge --pr 42          Merge la PR #42
═══════════════════════════════════════════════
```

---

## Priorité des outils

**IMPORTANT** : Toujours privilégier les outils MCP GitHub quand disponibles.

| Action | Priorité 1 (MCP) | Fallback (CLI) |
|--------|------------------|----------------|
| Créer branche | `mcp__github__create_branch` | `git checkout -b` |
| Créer PR | `mcp__github__create_pull_request` | `gh pr create` |
| Lister PRs | `mcp__github__list_pull_requests` | `gh pr list` |
| Voir PR | `mcp__github__get_pull_request` | `gh pr view` |
| Status CI | `mcp__github__get_pull_request_status` | `gh pr checks` |
| Merger PR | `mcp__github__merge_pull_request` | `gh pr merge` |
| Commenter | `mcp__github__add_issue_comment` | `gh pr comment` |

**Git local** (toujours CLI - pas de MCP) :
- `git status`, `git add`, `git commit`, `git push`
- `git branch`, `git checkout`, `git diff`

**Extraction owner/repo pour MCP** :
```bash
git remote get-url origin | sed -E 's#.*[:/]([^/]+)/([^/.]+)(\.git)?$#\1 \2#'
```

---

## Action: --commit

Workflow complet pour commiter et créer une PR.

### 1. Vérifier les changements

```bash
git status --porcelain
```

- **Si aucun changement** : Erreur "Aucun changement à commiter"
- **Si changements** : Continuer

### 2. Gestion de la branche (AUTONOME)

**Règles de décision AUTOMATIQUE** :

1. **Si `main` ou `master`** : CRÉER nouvelle branche automatiquement
2. **Si autre branche** : Analyser la cohérence :
   - Extraire le type et scope du nom de branche
   - Analyser les fichiers modifiés
   - **Si cohérent** : Utiliser la branche existante
   - **Si NON cohérent** : CRÉER nouvelle branche depuis main

**Détection de cohérence** :

| Branche | Fichiers modifiés | Décision |
|---------|-------------------|----------|
| `feat/auth` | `src/auth/*` | Cohérent |
| `feat/auth` | `docs/readme.md` | Nouvelle branche |
| `fix/api-error` | `src/api/*` | Cohérent |

**IMPORTANT** : Ne JAMAIS demander à l'utilisateur quelle branche utiliser.

### 3. Stage et Commit

**Stage tous les fichiers** :
```bash
git add -A
```

**Générer le message** (Conventional Commits) :
```
<type>(<scope>): <description>

[body optionnel]
```

| Type | Usage |
|------|-------|
| `feat` | Nouvelle fonctionnalité |
| `fix` | Correction de bug |
| `refactor` | Refactoring |
| `docs` | Documentation |
| `test` | Tests |
| `chore` | Maintenance |
| `ci` | CI/CD |

**INTERDIT** :
- Jamais de mention d'IA dans le message
- Jamais de "Generated by", "Co-authored-by AI"

### 4. Push

```bash
git push -u origin <branch>
```

### 5. Création de PR

**Via MCP (priorité)** :
```
mcp__github__create_pull_request:
  owner: <owner>
  repo: <repo>
  title: "<type>(<scope>): <description>"
  head: <branch>
  base: main
  body: <description>
```

**Format du body** :
```markdown
## Summary
<2-3 bullet points>

## Changes
<Liste des fichiers modifiés>

## Test plan
<Comment tester>
```

### Output --commit

```
═══════════════════════════════════════════════
  /git --commit
═══════════════════════════════════════════════

| Étape   | Status                           |
|---------|----------------------------------|
| Branche | `feat/add-user-auth`             |
| Commit  | `feat(auth): add user auth`      |
| Push    | origin/feat/add-user-auth        |
| PR      | #42 - feat(auth): add user auth  |

URL: https://github.com/<owner>/<repo>/pull/42
═══════════════════════════════════════════════
```

---

## Action: --merge

Merge intelligent avec validation CI et auto-fix.

### Workflow

1. **Sync avec main** (rebase)
2. **Attente CI** si en cours
3. **Auto-fix** si CI échoue (max 3 tentatives)
4. **Merge squash**
5. **Cleanup** branche

### 1. Détection du contexte

```bash
BRANCH=$(git branch --show-current)
MAIN_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
```

### 2. Trouver la PR

**MCP (prioritaire)** :
```
mcp__github__list_pull_requests:
  owner: <owner>
  repo: <repo>
  head: "owner:BRANCH"
  state: "open"
```

**Si aucune PR trouvée** :
```
❌ Aucune PR trouvée pour cette branche
→ Créez d'abord une PR avec /git --commit
```

### 3. Validation garde-fous

- Pas sur main/master
- PR existe et est ouverte
- Pas de conflits
- **Toutes les tasks Taskwarrior sont DONE** (si session existe)

**Validation des tasks :**
```bash
SESSION_FILE="$HOME/.claude/sessions/${BRANCH#*/}.json"
if [[ -f "$SESSION_FILE" ]]; then
    PROJECT=$(jq -r '.project' "$SESSION_FILE")
    PENDING=$(task project:"$PROJECT" status:pending count 2>/dev/null || echo "0")
    if [[ "$PENDING" -gt 0 ]]; then
        echo "❌ BLOQUÉ: $PENDING task(s) non terminée(s)"
        task project:"$PROJECT" status:pending
        echo "→ Terminez toutes les tasks avant le merge"
        exit 1
    fi
fi
```

### 4. Sync avec main (REBASE)

```bash
git fetch origin "$MAIN_BRANCH"
BEHIND=$(git rev-list --count HEAD.."origin/$MAIN_BRANCH")
if [[ "$BEHIND" -gt 0 ]]; then
    git rebase "origin/$MAIN_BRANCH"
    git push --force-with-lease
fi
```

### 5. Boucle CI avec auto-fix

```
MAX_FIX_ATTEMPTS = 3
CI_POLL_INTERVAL = 30 secondes

WHILE true:
    status = get_ci_status(PR_NUMBER)

    CASE "success":
        → Procéder au merge

    CASE "pending":
        → Attendre 30 secondes

    CASE "failure":
        fix_attempts++
        IF fix_attempts > 3:
            → Poster commentaire détaillé sur PR
            → Abandon
        ELSE:
            → Analyser l'erreur CI
            → Appliquer fix automatique
            → Commit + Push
```

### 6. Merge (SQUASH)

```
mcp__github__merge_pull_request:
  owner: <owner>
  repo: <repo>
  pull_number: <number>
  merge_method: "squash"
```

### 7. Cleanup

```bash
# Nettoyer les branches
git push origin --delete "$BRANCH"
git branch -D "$BRANCH"
git checkout "$MAIN_BRANCH"
git pull origin "$MAIN_BRANCH"

# Nettoyer la session Taskwarrior (si existe)
SESSION_FILE="$HOME/.claude/sessions/${BRANCH#*/}.json"
if [[ -f "$SESSION_FILE" ]]; then
    PROJECT=$(jq -r '.project' "$SESSION_FILE")
    # Archiver les tasks (pas delete, status:deleted)
    yes | task project:"$PROJECT" modify status:deleted 2>/dev/null || true
    # Supprimer le fichier de session
    rm -f "$SESSION_FILE"
fi
```

### Output --merge

```
═══════════════════════════════════════════════
  ✓ PR #42 merged successfully
═══════════════════════════════════════════════

  Branch  : feat/add-auth → main
  Method  : squash
  Rebase  : ✓ Synced (was 3 commits behind)
  CI      : ✓ Passed (2m 34s)
  Commits : 5 commits → 1 squashed

  Cleanup:
    ✓ Remote branch deleted
    ✓ Local branch deleted
    ✓ Switched to main
    ✓ Pulled latest (now at abc1234)
    ✓ Session archived

═══════════════════════════════════════════════
```

---

## GARDE-FOUS (ABSOLUS)

| Action | Status |
|--------|--------|
| Merge automatique sans validation | ❌ **INTERDIT** |
| Push sur main/master | ❌ **INTERDIT** |
| Force merge si CI échoue x3 | ❌ **INTERDIT** |
| Push sans --force-with-lease | ❌ **INTERDIT** |
| Mentions IA dans commits | ❌ **INTERDIT** |
| Merge avec conflits | ❌ **INTERDIT** |

---

## Cas spéciaux

### --commit --amend

1. Vérifier qu'on n'est PAS sur main/master
2. Vérifier que le dernier commit n'est pas pushé
3. `git commit --amend --no-edit`

### --commit --no-pr

Skip la création de PR, s'arrête après le push.

### --merge --dry-run

Vérifie tout sans merger :
- Valide les garde-fous
- Vérifie le statut CI
- Affiche ce qui serait fait

### --merge --strategy

Force une stratégie de merge différente :
- `squash` (défaut) : Combine tous les commits
- `merge` : Crée un merge commit
- `rebase` : Applique les commits sur main

---

## Voir aussi

- `/feature <description>` - Développer une fonctionnalité
- `/fix <description>` - Corriger un bug
- `/review --pr` - Demander une review CodeRabbit
