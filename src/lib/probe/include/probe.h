// AUTO-GENERATED BY CBINDGEN - DO NOT EDIT
// Probe - Cross-platform system metrics library

#ifndef PROBE_H
#define PROBE_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

// ============================================================================
// ERROR CODES
// ============================================================================

#define PROBE_OK 0
#define PROBE_ERR_NOT_SUPPORTED 1
#define PROBE_ERR_PERMISSION 2
#define PROBE_ERR_NOT_FOUND 3
#define PROBE_ERR_INVALID_PARAM 4
#define PROBE_ERR_IO 5
#define PROBE_ERR_INTERNAL 99

// ============================================================================
// CONSTANTS
// ============================================================================

#define PROBE_MAX_PATH_LEN 256

// ============================================================================
// TYPES
// ============================================================================

// Result type for FFI calls
typedef struct {
    bool success;
    int error_code;
    const char* error_message;
} ProbeResult;

// System CPU metrics
typedef struct {
    double user_percent;
    double system_percent;
    double idle_percent;
    double iowait_percent;
    double steal_percent;
    uint32_t cores;
    uint64_t frequency_mhz;
} SystemCPU;

// System memory metrics
typedef struct {
    uint64_t total_bytes;
    uint64_t available_bytes;
    uint64_t used_bytes;
    uint64_t cached_bytes;
    uint64_t buffers_bytes;
    uint64_t swap_total_bytes;
    uint64_t swap_used_bytes;
} SystemMemory;

// Load average
typedef struct {
    double load_1min;
    double load_5min;
    double load_15min;
} LoadAverage;

// Process state
typedef enum {
    PROCESS_STATE_RUNNING = 0,
    PROCESS_STATE_SLEEPING = 1,
    PROCESS_STATE_WAITING = 2,
    PROCESS_STATE_ZOMBIE = 3,
    PROCESS_STATE_STOPPED = 4,
    PROCESS_STATE_UNKNOWN = 255,
} ProcessState;

// Process metrics
typedef struct {
    int32_t pid;
    double cpu_percent;
    uint64_t memory_rss_bytes;
    uint64_t memory_vms_bytes;
    double memory_percent;
    uint32_t num_threads;
    uint32_t num_fds;
    uint64_t read_bytes_per_sec;
    uint64_t write_bytes_per_sec;
    ProcessState state;
} ProcessMetrics;

// CPU pressure metrics (PSI - Linux only)
typedef struct {
    double some_avg10;
    double some_avg60;
    double some_avg300;
    uint64_t some_total_us;
} CPUPressure;

// Memory pressure metrics (PSI - Linux only)
typedef struct {
    double some_avg10;
    double some_avg60;
    double some_avg300;
    uint64_t some_total_us;
    double full_avg10;
    double full_avg60;
    double full_avg300;
    uint64_t full_total_us;
} MemoryPressure;

// I/O pressure metrics (PSI - Linux only)
typedef struct {
    double some_avg10;
    double some_avg60;
    double some_avg300;
    uint64_t some_total_us;
    double full_avg10;
    double full_avg60;
    double full_avg300;
    uint64_t full_total_us;
} IOPressure;

// Partition information
typedef struct {
    char device[PROBE_MAX_PATH_LEN];
    char mount_point[PROBE_MAX_PATH_LEN];
    char fs_type[64];
    char options[PROBE_MAX_PATH_LEN];
} Partition;

// List of partitions
typedef struct {
    Partition* items;
    size_t count;
    size_t capacity;
} PartitionList;

// Disk usage information
typedef struct {
    char path[PROBE_MAX_PATH_LEN];
    uint64_t total_bytes;
    uint64_t used_bytes;
    uint64_t free_bytes;
    double used_percent;
    uint64_t inodes_total;
    uint64_t inodes_used;
    uint64_t inodes_free;
} DiskUsage;

// Disk I/O statistics
typedef struct {
    char device[64];
    uint64_t reads_completed;
    uint64_t sectors_read;
    uint64_t read_time_ms;
    uint64_t writes_completed;
    uint64_t sectors_written;
    uint64_t write_time_ms;
    uint64_t io_in_progress;
    uint64_t io_time_ms;
    uint64_t weighted_io_time_ms;
} DiskIOStats;

// List of disk I/O stats
typedef struct {
    DiskIOStats* items;
    size_t count;
    size_t capacity;
} DiskIOStatsList;

// Network interface information
typedef struct {
    char name[64];
    char mac_address[18];
    uint32_t mtu;
    bool is_up;
    bool is_loopback;
} NetInterface;

// List of network interfaces
typedef struct {
    NetInterface* items;
    size_t count;
    size_t capacity;
} NetInterfaceList;

// Network interface statistics
typedef struct {
    char interface[64];
    uint64_t rx_bytes;
    uint64_t rx_packets;
    uint64_t rx_errors;
    uint64_t rx_drops;
    uint64_t tx_bytes;
    uint64_t tx_packets;
    uint64_t tx_errors;
    uint64_t tx_drops;
} NetStats;

// List of network stats
typedef struct {
    NetStats* items;
    size_t count;
    size_t capacity;
} NetStatsList;

// System-wide I/O statistics
typedef struct {
    uint64_t read_ops;
    uint64_t read_bytes;
    uint64_t write_ops;
    uint64_t write_bytes;
} IOStats;

// Quota limits flags (bitfield indicating which fields are valid)
#define QUOTA_FLAG_CPU       (1 << 0)
#define QUOTA_FLAG_MEMORY    (1 << 1)
#define QUOTA_FLAG_PIDS      (1 << 2)
#define QUOTA_FLAG_NOFILE    (1 << 3)
#define QUOTA_FLAG_CPU_TIME  (1 << 4)
#define QUOTA_FLAG_DATA      (1 << 5)
#define QUOTA_FLAG_IO_READ   (1 << 6)
#define QUOTA_FLAG_IO_WRITE  (1 << 7)

// Resource quota limits (read-only detection)
typedef struct {
    uint64_t cpu_quota_us;        // CPU quota in microseconds per period
    uint64_t cpu_period_us;       // CPU period in microseconds
    uint64_t memory_limit_bytes;  // Memory limit in bytes
    uint64_t pids_limit;          // Maximum PIDs
    uint64_t nofile_limit;        // Maximum file descriptors
    uint64_t cpu_time_limit_secs; // Maximum CPU time in seconds
    uint64_t data_limit_bytes;    // Maximum data/heap size in bytes
    uint64_t io_read_bps;         // I/O read bandwidth limit
    uint64_t io_write_bps;        // I/O write bandwidth limit
    uint32_t flags;               // Flags indicating which fields are valid
} QuotaLimits;

// Current resource usage
typedef struct {
    uint64_t memory_bytes;        // Current memory usage
    uint64_t memory_limit_bytes;  // Memory limit (0 = no limit)
    uint64_t pids_current;        // Current process count
    uint64_t pids_limit;          // PIDs limit (0 = no limit)
    double cpu_percent;           // Current CPU usage percentage
    double cpu_limit_percent;     // CPU limit percentage (0 = no limit)
} QuotaUsage;

// Container runtime type (legacy - use RuntimeType for new code)
typedef enum {
    CONTAINER_RUNTIME_NONE = 0,
    CONTAINER_RUNTIME_DOCKER = 1,
    CONTAINER_RUNTIME_PODMAN = 2,
    CONTAINER_RUNTIME_LXC = 3,
    CONTAINER_RUNTIME_KUBERNETES = 4,
    CONTAINER_RUNTIME_FREEBSD_JAIL = 5,
    CONTAINER_RUNTIME_UNKNOWN = 255,
} ContainerRuntime;

// Extended runtime type (covers all runtimes and orchestrators)
typedef enum {
    // No runtime / not containerized
    RUNTIME_NONE = 0,
    // Container runtimes (1-19)
    RUNTIME_DOCKER = 1,
    RUNTIME_PODMAN = 2,
    RUNTIME_CONTAINERD = 3,
    RUNTIME_CRIO = 4,
    RUNTIME_LXC = 5,
    RUNTIME_LXD = 6,
    RUNTIME_SYSTEMD_NSPAWN = 7,
    RUNTIME_FIRECRACKER = 8,
    RUNTIME_FREEBSD_JAIL = 9,
    // Orchestrators (20-39)
    RUNTIME_KUBERNETES = 20,
    RUNTIME_NOMAD = 21,
    RUNTIME_DOCKER_SWARM = 22,
    RUNTIME_OPENSHIFT = 23,
    // Cloud-specific (40-59)
    RUNTIME_AWS_ECS = 40,
    RUNTIME_AWS_FARGATE = 41,
    RUNTIME_GOOGLE_GKE = 42,
    RUNTIME_AZURE_AKS = 43,
    // Unknown
    RUNTIME_UNKNOWN = 254,
} RuntimeType;

#define MAX_AVAILABLE_RUNTIMES 16

// Information about an available runtime on the host
typedef struct {
    RuntimeType runtime;                   // Runtime type
    char socket_path[PROBE_MAX_PATH_LEN]; // Unix socket path
    char version[64];                      // Version string
    bool is_running;                       // Whether responsive
} AvailableRuntimeInfo;

// Full runtime environment information
typedef struct {
    bool is_containerized;                 // Whether in a container
    RuntimeType container_runtime;         // Container runtime
    RuntimeType orchestrator;              // Orchestrator (may differ)
    char container_id[65];                 // Container ID
    char workload_id[65];                  // Workload/allocation ID
    char workload_name[128];               // Workload/pod name
    char namespace[64];                    // Namespace
    uint32_t available_count;              // Number of available runtimes
    AvailableRuntimeInfo available_runtimes[MAX_AVAILABLE_RUNTIMES]; // Available runtimes
} RuntimeInfo;

// Container information
typedef struct {
    bool is_containerized;        // Whether running in a container
    ContainerRuntime runtime;     // Container runtime type
    char container_id[65];        // Container ID (null-terminated)
} ContainerInfo;

// ============================================================================
// LIFECYCLE FUNCTIONS
// ============================================================================

// Initialize the probe library. Must be called once at startup.
ProbeResult probe_init(void);

// Shutdown the probe library. Should be called at program exit.
void probe_shutdown(void);

// ============================================================================
// SYSTEM METRICS FUNCTIONS
// ============================================================================

// Collect system CPU metrics
ProbeResult probe_collect_cpu(SystemCPU* out);

// Collect system memory metrics
ProbeResult probe_collect_memory(SystemMemory* out);

// Collect system load average
ProbeResult probe_collect_load(LoadAverage* out);

// ============================================================================
// PROCESS METRICS FUNCTIONS
// ============================================================================

// Collect metrics for a specific process
ProbeResult probe_collect_process(int32_t pid, ProcessMetrics* out);

// ============================================================================
// PRESSURE METRICS FUNCTIONS (PSI - Linux only)
// ============================================================================

// Collect CPU pressure metrics
ProbeResult probe_collect_cpu_pressure(CPUPressure* out);

// Collect memory pressure metrics
ProbeResult probe_collect_memory_pressure(MemoryPressure* out);

// Collect I/O pressure metrics
ProbeResult probe_collect_io_pressure(IOPressure* out);

// ============================================================================
// DISK METRICS FUNCTIONS
// ============================================================================

// List disk partitions
ProbeResult probe_list_partitions(PartitionList* out);

// Free a partition list
void probe_free_partition_list(PartitionList* list);

// Collect disk usage for a specific path
ProbeResult probe_collect_disk_usage(const char* path, DiskUsage* out);

// Collect disk I/O statistics for all devices
ProbeResult probe_collect_disk_io(DiskIOStatsList* out);

// Free a disk I/O stats list
void probe_free_disk_io_list(DiskIOStatsList* list);

// ============================================================================
// NETWORK METRICS FUNCTIONS
// ============================================================================

// List network interfaces
ProbeResult probe_list_net_interfaces(NetInterfaceList* out);

// Free a network interface list
void probe_free_net_interface_list(NetInterfaceList* list);

// Collect network statistics for all interfaces
ProbeResult probe_collect_net_stats(NetStatsList* out);

// Free a network stats list
void probe_free_net_stats_list(NetStatsList* list);

// ============================================================================
// I/O METRICS FUNCTIONS
// ============================================================================

// Collect system-wide I/O statistics
ProbeResult probe_collect_io_stats(IOStats* out);

// ============================================================================
// CONTEXT SWITCHES (Linux only)
// ============================================================================

// Context switch statistics
typedef struct {
    uint64_t voluntary;      // Voluntary context switches (process yielded CPU)
    uint64_t involuntary;    // Involuntary context switches (preempted by scheduler)
    uint64_t system_total;   // System-wide total context switches
} ContextSwitches;

// Collect system-wide context switch count
ProbeResult probe_collect_system_context_switches(uint64_t* out);

// Collect context switches for a specific process
ProbeResult probe_collect_process_context_switches(int32_t pid, ContextSwitches* out);

// Collect context switches for the current process
ProbeResult probe_collect_self_context_switches(ContextSwitches* out);

// ============================================================================
// THERMAL METRICS (Linux via /sys/class/hwmon)
// ============================================================================

// Maximum thermal zones to return
#define MAX_THERMAL_ZONES 32

// Thermal zone information
typedef struct {
    char name[64];           // Device name (e.g., "coretemp", "acpitz")
    char label[64];          // Zone label (e.g., "Core 0", "Package id 0")
    double temp_celsius;     // Current temperature in Celsius
    double temp_max;         // Maximum safe temperature (if has_max is true)
    double temp_crit;        // Critical temperature (if has_crit is true)
    bool has_max;            // Whether temp_max is valid
    bool has_crit;           // Whether temp_crit is valid
} ThermalZone;

// List of thermal zones
typedef struct {
    ThermalZone* items;
    size_t count;
    size_t capacity;
} ThermalZoneList;

// Check if thermal monitoring is supported
bool probe_thermal_is_supported(void);

// Collect thermal zones
ProbeResult probe_collect_thermal_zones(ThermalZoneList* out);

// Free a thermal zone list
void probe_free_thermal_list(ThermalZoneList* list);

// ============================================================================
// AGGREGATED METRICS COLLECTION
// ============================================================================

// Maximum items for arrays in AllMetrics
#define MAX_ALL_METRICS_ITEMS 64

// All pressure metrics combined
typedef struct {
    CPUPressure cpu;
    MemoryPressure memory;
    IOPressure io;
    bool available;  // Whether pressure metrics are available (Linux only)
} AllPressure;

// All system metrics collected in one call
typedef struct {
    SystemCPU cpu;
    SystemMemory memory;
    LoadAverage load;
    IOStats io_stats;
    AllPressure pressure;
    uint64_t timestamp_ns;

    uint32_t partition_count;
    uint32_t disk_usage_count;
    uint32_t disk_io_count;
    uint32_t net_interface_count;
    uint32_t net_stats_count;

    Partition partitions[MAX_ALL_METRICS_ITEMS];
    DiskUsage disk_usage[MAX_ALL_METRICS_ITEMS];
    DiskIOStats disk_io[MAX_ALL_METRICS_ITEMS];
    NetInterface net_interfaces[MAX_ALL_METRICS_ITEMS];
    NetStats net_stats[MAX_ALL_METRICS_ITEMS];
} AllMetrics;

// Collect all system metrics in one call
// This is more efficient than calling each collector individually
ProbeResult probe_collect_all(AllMetrics* out);

// ============================================================================
// RESOURCE QUOTA FUNCTIONS (READ-ONLY DETECTION)
// ============================================================================

// Check if quota detection is supported on this platform
bool probe_quota_is_supported(void);

// Read resource limits for a process
// Returns detected limits (cgroups, rctl, or rlimits depending on platform)
ProbeResult probe_quota_read_limits(int32_t pid, QuotaLimits* out);

// Read current resource usage for a process
ProbeResult probe_quota_read_usage(int32_t pid, QuotaUsage* out);

// Detect container runtime (legacy - use probe_detect_runtime for new code)
ProbeResult probe_detect_container(ContainerInfo* out);

// ============================================================================
// UNIVERSAL RUNTIME DETECTION FUNCTIONS
// ============================================================================

// Detect full runtime environment (inside detection + available runtimes)
ProbeResult probe_detect_runtime(RuntimeInfo* out);

// Check if running inside a container (fast check)
bool probe_is_containerized(void);

// Get container runtime name as static string
// Returns "none" if not containerized
const char* probe_get_runtime_name(void);

// ============================================================================
// CACHE MANAGEMENT FUNCTIONS
// ============================================================================

// Cache policy presets
#define PROBE_CACHE_POLICY_DEFAULT       0  // Balanced TTLs
#define PROBE_CACHE_POLICY_HIGH_FREQ     1  // Shorter TTLs for frequent collection
#define PROBE_CACHE_POLICY_LOW_FREQ      2  // Longer TTLs for infrequent collection
#define PROBE_CACHE_POLICY_NO_CACHE      3  // TTL=0, for testing

// Metric types for cache TTL configuration
#define PROBE_METRIC_CPU_SYSTEM          0
#define PROBE_METRIC_CPU_PRESSURE        1
#define PROBE_METRIC_MEMORY_SYSTEM       2
#define PROBE_METRIC_MEMORY_PRESSURE     3
#define PROBE_METRIC_LOAD                4
#define PROBE_METRIC_DISK_PARTITIONS     5
#define PROBE_METRIC_DISK_USAGE          6
#define PROBE_METRIC_DISK_IO             7
#define PROBE_METRIC_NET_INTERFACES      8
#define PROBE_METRIC_NET_STATS           9
#define PROBE_METRIC_IO_STATS            10
#define PROBE_METRIC_IO_PRESSURE         11

// Enable caching with default policies
ProbeResult probe_cache_enable(void);

// Enable caching with a specific policy preset
ProbeResult probe_cache_enable_with_policy(uint32_t policy);

// Disable caching and revert to direct collection
ProbeResult probe_cache_disable(void);

// Check if caching is currently enabled
bool probe_cache_is_enabled(void);

// Set the TTL for a specific metric type (in milliseconds)
ProbeResult probe_cache_set_ttl(uint8_t metric_type, uint64_t ttl_ms);

// Invalidate all cached metrics
ProbeResult probe_cache_invalidate_all(void);

// Invalidate a specific metric type from the cache
ProbeResult probe_cache_invalidate(uint8_t metric_type);

// ============================================================================
// CACHED COLLECTION FUNCTIONS
// ============================================================================

// Collect system CPU metrics with caching (if enabled)
ProbeResult probe_collect_cpu_cached(SystemCPU* out);

// Collect system memory metrics with caching (if enabled)
ProbeResult probe_collect_memory_cached(SystemMemory* out);

// Collect system load average with caching (if enabled)
ProbeResult probe_collect_load_cached(LoadAverage* out);

// ============================================================================
// NETWORK CONNECTIONS (TCP, UDP, Unix sockets with process resolution)
// ============================================================================

// Maximum address length for IPv6
#define MAX_ADDR_LEN 46

// Socket state (matching Linux TCP states)
typedef enum {
    SOCKET_STATE_UNKNOWN = 0,
    SOCKET_STATE_ESTABLISHED = 1,
    SOCKET_STATE_SYN_SENT = 2,
    SOCKET_STATE_SYN_RECV = 3,
    SOCKET_STATE_FIN_WAIT1 = 4,
    SOCKET_STATE_FIN_WAIT2 = 5,
    SOCKET_STATE_TIME_WAIT = 6,
    SOCKET_STATE_CLOSE = 7,
    SOCKET_STATE_CLOSE_WAIT = 8,
    SOCKET_STATE_LAST_ACK = 9,
    SOCKET_STATE_LISTEN = 10,
    SOCKET_STATE_CLOSING = 11,
} SocketState;

// Address family
typedef enum {
    ADDRESS_FAMILY_IPV4 = 4,
    ADDRESS_FAMILY_IPV6 = 6,
} AddressFamily;

// TCP connection information
typedef struct {
    AddressFamily family;              // IPv4 or IPv6
    char local_addr[MAX_ADDR_LEN];     // Local IP address
    uint16_t local_port;               // Local port
    char remote_addr[MAX_ADDR_LEN];    // Remote IP address
    uint16_t remote_port;              // Remote port
    SocketState state;                 // Connection state
    int32_t pid;                       // Process ID (-1 if unknown)
    char process_name[64];             // Process name (empty if unknown)
    uint64_t inode;                    // Socket inode number
    uint32_t rx_queue;                 // Receive queue size
    uint32_t tx_queue;                 // Transmit queue size
} TcpConnection;

// List of TCP connections
typedef struct {
    TcpConnection* items;
    size_t count;
    size_t capacity;
} TcpConnectionList;

// UDP socket information
typedef struct {
    AddressFamily family;              // IPv4 or IPv6
    char local_addr[MAX_ADDR_LEN];     // Local IP address
    uint16_t local_port;               // Local port
    char remote_addr[MAX_ADDR_LEN];    // Remote IP (may be 0.0.0.0)
    uint16_t remote_port;              // Remote port (may be 0)
    SocketState state;                 // Connection state
    int32_t pid;                       // Process ID (-1 if unknown)
    char process_name[64];             // Process name (empty if unknown)
    uint64_t inode;                    // Socket inode number
    uint32_t rx_queue;                 // Receive queue size
    uint32_t tx_queue;                 // Transmit queue size
} UdpConnection;

// List of UDP connections
typedef struct {
    UdpConnection* items;
    size_t count;
    size_t capacity;
} UdpConnectionList;

// Unix socket information
typedef struct {
    char path[PROBE_MAX_PATH_LEN];     // Socket path (may be empty)
    char socket_type[16];              // stream, dgram, seqpacket
    SocketState state;                 // Connection state
    int32_t pid;                       // Process ID (-1 if unknown)
    char process_name[64];             // Process name (empty if unknown)
    uint64_t inode;                    // Socket inode number
} UnixSocket;

// List of Unix sockets
typedef struct {
    UnixSocket* items;
    size_t count;
    size_t capacity;
} UnixSocketList;

// Aggregated TCP connection statistics
typedef struct {
    uint32_t established;
    uint32_t syn_sent;
    uint32_t syn_recv;
    uint32_t fin_wait1;
    uint32_t fin_wait2;
    uint32_t time_wait;
    uint32_t close;
    uint32_t close_wait;
    uint32_t last_ack;
    uint32_t listen;
    uint32_t closing;
} TcpStats;

// Collect all TCP connections
ProbeResult probe_collect_tcp_connections(TcpConnectionList* out);

// Free a TCP connection list
void probe_free_tcp_connection_list(TcpConnectionList* list);

// Collect all UDP sockets
ProbeResult probe_collect_udp_connections(UdpConnectionList* out);

// Free a UDP connection list
void probe_free_udp_connection_list(UdpConnectionList* list);

// Collect all Unix sockets
ProbeResult probe_collect_unix_sockets(UnixSocketList* out);

// Free a Unix socket list
void probe_free_unix_socket_list(UnixSocketList* list);

// Collect TCP connection statistics
ProbeResult probe_collect_tcp_stats(TcpStats* out);

// Find which process owns a specific port
// If no process is found, *out will be -1
ProbeResult probe_find_process_by_port(uint16_t port, bool tcp, int32_t* out);

// ============================================================================
// PLATFORM INFO FUNCTIONS
// ============================================================================

// Get the platform name ("linux", "darwin", "freebsd", etc.)
const char* probe_get_platform(void);

#ifdef __cplusplus
}
#endif

#endif // PROBE_H
