name: Release

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'      # v1.0.0
      - 'v[0-9]+.[0-9]+.[0-9]+-*'    # v1.0.0-rc.1, v1.0.0-beta.1
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type (auto = detect from commits)'
        required: false
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
        default: auto

concurrency:
  group: release
  cancel-in-progress: false

permissions:
  contents: write

env:
  GO_VERSION: '1.25.5'

jobs:
  # =============================================================================
  # Determine version
  # =============================================================================
  version:
    name: Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_new_tag: ${{ steps.version.outputs.is_new_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
        with:
          fetch-depth: 0

      - name: Calculate version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION="${{ github.ref_name }}"
            IS_NEW_TAG="false"
            BUMP_TYPE="tag"
          else
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            VERSION_NUM=${LATEST_TAG#v}

            IFS='.' read -r MAJOR MINOR PATCH <<< "${VERSION_NUM%%-*}"
            MAJOR=${MAJOR:-0}
            MINOR=${MINOR:-0}
            PATCH=${PATCH:-0}

            BUMP_TYPE="${{ inputs.bump }}"

            if [[ "$BUMP_TYPE" == "auto" || -z "$BUMP_TYPE" ]]; then
              echo "Analyzing commits since $LATEST_TAG..."

              if [[ "$LATEST_TAG" == "v0.0.0" ]]; then
                COMMITS=$(git log --oneline --format="%s")
              else
                COMMITS=$(git log "${LATEST_TAG}..HEAD" --oneline --format="%s")
              fi

              echo "Commits found:"
              echo "$COMMITS" | head -20

              if echo "$COMMITS" | grep -qiE '^[a-z]+(\(.+\))?!:|BREAKING CHANGE:'; then
                BUMP_TYPE="major"
                echo "Detected: BREAKING CHANGE → major"
              elif echo "$COMMITS" | grep -qiE '^feat(\(.+\))?:'; then
                BUMP_TYPE="minor"
                echo "Detected: feat commits → minor"
              elif echo "$COMMITS" | grep -qiE '^fix(\(.+\))?:'; then
                BUMP_TYPE="patch"
                echo "Detected: fix commits → patch"
              else
                BUMP_TYPE="patch"
                echo "No conventional commits detected → patch (default)"
              fi
            fi

            case "$BUMP_TYPE" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac

            VERSION="v${MAJOR}.${MINOR}.${PATCH}"
            IS_NEW_TAG="true"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "is_new_tag=${IS_NEW_TAG}" >> $GITHUB_OUTPUT
          echo "bump_type=${BUMP_TYPE}" >> $GITHUB_OUTPUT
          echo ""
          echo "=== Version Summary ==="
          echo "Previous: $LATEST_TAG"
          echo "Bump: $BUMP_TYPE"
          echo "New: $VERSION"

  # =============================================================================
  # Build all platforms
  # =============================================================================
  build:
    name: Build ${{ matrix.goos }}/${{ matrix.goarch }}
    needs: version
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux
          - { goos: linux, goarch: amd64 }
          - { goos: linux, goarch: arm64 }
          - { goos: linux, goarch: arm }
          - { goos: linux, goarch: 386 }
          - { goos: linux, goarch: riscv64 }
          # macOS
          - { goos: darwin, goarch: amd64 }
          - { goos: darwin, goarch: arm64 }
          # FreeBSD
          - { goos: freebsd, goarch: amd64 }
          - { goos: freebsd, goarch: arm64 }
          - { goos: freebsd, goarch: arm }
          - { goos: freebsd, goarch: 386 }
          - { goos: freebsd, goarch: riscv64 }
          # OpenBSD
          - { goos: openbsd, goarch: amd64 }
          - { goos: openbsd, goarch: arm64 }
          - { goos: openbsd, goarch: arm }
          - { goos: openbsd, goarch: 386 }
          # NetBSD
          - { goos: netbsd, goarch: amd64 }
          - { goos: netbsd, goarch: arm64 }
          - { goos: netbsd, goarch: arm }
          - { goos: netbsd, goarch: 386 }
          # DragonFlyBSD
          - { goos: dragonfly, goarch: amd64 }

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Set up Go
        uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff # v5.6.0
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: src/go.sum

      - name: Install Wire
        run: go install github.com/google/wire/cmd/wire@latest

      - name: Generate code
        working-directory: src
        run: wire ./internal/bootstrap/

      - name: Build binary
        working-directory: src
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          go build -buildvcs=false \
            -ldflags="-s -w -X main.version=${{ needs.version.outputs.version }}" \
            -o ../supervizio-${{ matrix.goos }}-${{ matrix.goarch }} \
            ./cmd/daemon

      - name: Upload artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: supervizio-${{ matrix.goos }}-${{ matrix.goarch }}
          path: supervizio-${{ matrix.goos }}-${{ matrix.goarch }}
          retention-days: 1

  # =============================================================================
  # Generate Linux Packages (.deb, .rpm, .apk)
  # =============================================================================
  # Packages are signed with GPG for trusted distribution.
  # Required secrets: GPG_SIGNING_KEY, GPG_PASSPHRASE (optional)
  # =============================================================================
  packages:
    name: Package ${{ matrix.format }} (${{ matrix.arch }})
    needs: [version, build]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        arch: [amd64, arm64]
        format: [deb, rpm, apk]
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Set up Go
        uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff # v5.6.0
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: src/go.sum

      - name: Download Linux binary
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: supervizio-linux-${{ matrix.arch }}

      - name: Prepare binary
        run: |
          # download-artifact@v4 extracts files directly (no subdirectory)
          ls -la
          chmod +x supervizio-linux-${{ matrix.arch }}
          ls -la supervizio-*

      - name: Install nfpm
        run: go install github.com/goreleaser/nfpm/v2/cmd/nfpm@v2.44.1

      - name: Import GPG key
        env:
          GPG_KEY: ${{ secrets.GPG_SIGNING_KEY }}
          GPG_PASS: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          if [ -z "$GPG_KEY" ]; then
            echo "GPG_SIGNING_KEY not set, skipping GPG import"
            exit 0
          fi
          echo "$GPG_KEY" | gpg --batch --import
          if [ -n "$GPG_PASS" ]; then
            echo "allow-preset-passphrase" >> ~/.gnupg/gpg-agent.conf
            gpg-connect-agent reloadagent /bye
          fi

      - name: Build package
        env:
          GOARCH: ${{ matrix.arch }}
        run: |
          # Strip 'v' prefix from version for package version
          export VERSION="${{ needs.version.outputs.version }}"
          VERSION="${VERSION#v}"
          export VERSION

          # Substitute environment variables in nfpm config
          envsubst < nfpm.yaml > nfpm-resolved.yaml
          echo "=== Resolved nfpm config ==="
          cat nfpm-resolved.yaml

          # Generate package
          nfpm package \
            --config nfpm-resolved.yaml \
            --packager ${{ matrix.format }} \
            --target ./

          # Verify package was created
          echo "=== Generated package ==="
          ls -la *.${{ matrix.format }}

      - name: Sign DEB package
        if: matrix.format == 'deb'
        continue-on-error: true
        env:
          GPG_KEY: ${{ secrets.GPG_SIGNING_KEY }}
        run: |
          if [ -z "$GPG_KEY" ]; then
            echo "GPG_SIGNING_KEY not set, skipping DEB signing"
            exit 0
          fi
          # Try debsigs (Ubuntu 24.04+) or dpkg-sig (older)
          if apt-cache show debsigs >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y debsigs
            KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | awk '{print $2}' | cut -d'/' -f2)
            for deb in *.deb; do
              [ -f "$deb" ] && debsigs --sign=origin -k "$KEY_ID" "$deb" || echo "debsigs failed for $deb"
            done
          elif apt-cache show dpkg-sig >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y dpkg-sig
            for deb in *.deb; do
              [ -f "$deb" ] && dpkg-sig --sign builder "$deb" || echo "dpkg-sig failed for $deb"
            done
          else
            echo "No DEB signing tool available (debsigs/dpkg-sig), skipping"
            echo "Note: APT repository will still be GPG-signed"
          fi

      - name: Sign RPM package
        if: matrix.format == 'rpm'
        continue-on-error: true
        env:
          GPG_KEY: ${{ secrets.GPG_SIGNING_KEY }}
        run: |
          if [ -z "$GPG_KEY" ]; then
            echo "GPG_SIGNING_KEY not set, skipping RPM signing"
            exit 0
          fi
          # Configure RPM macros for signing
          KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | awk '{print $2}' | cut -d'/' -f2)
          echo "%_gpg_name $KEY_ID" > ~/.rpmmacros
          for rpm in *.rpm; do
            [ -f "$rpm" ] && rpm --addsign "$rpm" 2>/dev/null || echo "RPM signing skipped for $rpm"
          done

      - name: Upload package
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: supervizio-${{ matrix.arch }}.${{ matrix.format }}
          path: "*.${{ matrix.format }}"
          retention-days: 1

  # =============================================================================
  # E2E Tests - Linux (Vagrant + Docker)
  # =============================================================================
  # Validates release PACKAGES work across Linux distributions and init systems.
  # Tests actual .deb/.rpm/.apk installation, not just raw binaries.
  # Must pass before release is published.
  # =============================================================================
  e2e-linux:
    name: E2E ${{ matrix.name }}
    needs: [version, packages]
    runs-on: ubuntu-24.04
    timeout-minutes: 25
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: Debian
            vm: debian13
            dockerfile: Dockerfile.debian
            init: systemd
            pkg_format: deb
            pkg_install: "sudo dpkg -i"
          - name: Fedora
            vm: fedora
            dockerfile: Dockerfile.fedora
            init: systemd
            pkg_format: rpm
            pkg_install: "sudo rpm -i"
          - name: Alpine
            vm: alpine
            dockerfile: Dockerfile.alpine
            init: openrc
            pkg_format: apk
            pkg_install: "sudo apk add --allow-untrusted"
          - name: Devuan
            vm: devuan
            dockerfile: Dockerfile.devuan
            init: sysvinit
            pkg_format: deb
            pkg_install: "sudo dpkg -i"
          - name: Alpine-runit
            vm: alpine-runit
            dockerfile: Dockerfile.alpine-runit
            init: runit
            pkg_format: apk
            pkg_install: "sudo apk add --allow-untrusted"
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Download package
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: supervizio-amd64.${{ matrix.pkg_format }}
          path: pkg

      - name: Prepare package
        run: |
          echo "=== Downloaded package ==="
          ls -la pkg/
          # Copy to bin for Dockerfile compatibility (expects bin/supervizio)
          mkdir -p bin
          cp pkg/*.${{ matrix.pkg_format }} bin/
          ls -la bin/

      # =========================================================================
      # VM Test via Vagrant + libvirt/KVM
      # =========================================================================
      - name: Setup KVM
        run: |
          if [ -e /dev/kvm ]; then
            echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
            sudo udevadm control --reload-rules
            sudo udevadm trigger --name-match=kvm
          fi

      - name: Install libvirt and Vagrant
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq libvirt-daemon-system libvirt-dev libvirt-clients qemu-kvm ruby-dev ruby-libvirt build-essential
          sudo systemctl start libvirtd
          sudo usermod -aG libvirt,kvm $USER

          # Install Vagrant from HashiCorp
          wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt-get update -qq && sudo apt-get install -y -qq vagrant
          vagrant plugin install vagrant-libvirt

      - name: Cache Vagrant box
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.vagrant.d/boxes
          key: vagrant-${{ matrix.vm }}-v1

      - name: Start VM
        working-directory: e2e
        run: sudo -E vagrant up ${{ matrix.vm }} --provider=libvirt

      - name: Sync folders
        working-directory: e2e
        run: |
          echo "=== Getting VM SSH config ==="
          sudo -E vagrant ssh-config ${{ matrix.vm }} 2>&1 | tee /tmp/ssh-config-${{ matrix.vm }} || true
          VM_IP=$(grep HostName /tmp/ssh-config-${{ matrix.vm }} | awk '{print $2}')
          echo "VM IP: $VM_IP"

          echo "=== Waiting for VM to be SSH-ready ==="
          for i in $(seq 1 36); do
            if timeout 2 bash -c "echo >/dev/tcp/$VM_IP/22" 2>/dev/null; then
              echo "Port 22 is open on $VM_IP"
              if sudo -E vagrant ssh ${{ matrix.vm }} -c "echo 'VM ready'" 2>/dev/null; then
                echo "=== VM is SSH-accessible after $((i * 5)) seconds ==="
                break
              else
                echo "Port open but SSH command failed (attempt $i/36)"
              fi
            else
              echo "Port 22 not yet open (attempt $i/36)"
            fi

            if [ "$i" = "36" ]; then
              echo "ERROR: VM not SSH-accessible after 180 seconds"
              sudo -E vagrant status ${{ matrix.vm }} || true
              cat /tmp/ssh-config-${{ matrix.vm }} || true
              sudo virsh list --all || true
              exit 1
            fi
            sleep 5
          done

          echo "=== Attempting vagrant rsync ==="
          if sudo -E vagrant rsync ${{ matrix.vm }} 2>&1; then
            echo "=== Rsync succeeded ==="
          else
            echo "=== Rsync failed, using tar-over-ssh fallback ==="
            sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo mkdir -p /setup /pkg /vagrant && sudo chmod 777 /setup /pkg /vagrant"
            tar -cv -C .. setup | sudo -E vagrant ssh ${{ matrix.vm }} -c "cd / && sudo tar -xv"
            tar -cv -C .. pkg | sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo tar -xv -C /pkg --strip-components=1"
            tar -cv . | sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo tar -xv -C /vagrant"
            sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo chown -R root:root /setup /pkg"
          fi

          echo "=== Verifying synced files ==="
          sudo -E vagrant ssh ${{ matrix.vm }} -c "ls -la /setup /pkg /vagrant"

      - name: Install package in VM
        working-directory: e2e
        run: |
          echo "=== Installing package via ${{ matrix.pkg_install }} ==="
          # shellcheck disable=SC2016 - Single quotes intentional for remote expansion
          sudo -E vagrant ssh "${{ matrix.vm }}" -c 'sudo ${{ matrix.pkg_install }} /pkg/*.${{ matrix.pkg_format }}'

      - name: Run VM tests
        working-directory: e2e
        run: sudo -E vagrant ssh "${{ matrix.vm }}" -c "sudo /vagrant/test-install.sh --skip-install"

      - name: Cleanup VM
        if: always()
        working-directory: e2e
        run: sudo vagrant destroy ${{ matrix.vm }} -f 2>/dev/null || true

      # =========================================================================
      # Container Test via Docker
      # =========================================================================
      - name: Build container
        run: docker build -f e2e/${{ matrix.dockerfile }} -t supervizio-${{ matrix.vm }}:test .

      - name: Test container
        run: docker run --rm supervizio-${{ matrix.vm }}:test

      - name: Collect logs on failure
        if: failure()
        working-directory: e2e
        run: |
          sudo vagrant status || true
          sudo virsh list --all || true

  # =============================================================================
  # E2E Tests - BSD (Vagrant + libvirt/KVM)
  # =============================================================================
  # Validates release binaries work across BSD variants.
  # Must pass before release is published.
  # =============================================================================
  e2e-bsd:
    name: E2E ${{ matrix.name }}
    needs: [version, build]
    runs-on: ubuntu-24.04
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: FreeBSD
            vm: freebsd
            goos: freebsd
          - name: OpenBSD
            vm: openbsd
            goos: openbsd
          - name: NetBSD
            vm: netbsd
            goos: netbsd
          - name: DragonFlyBSD
            vm: dragonfly
            goos: dragonfly
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Download BSD binary
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: supervizio-${{ matrix.goos }}-amd64
          path: bin

      - name: Prepare binary
        run: |
          mv bin/supervizio-${{ matrix.goos }}-amd64 bin/supervizio
          chmod +x bin/supervizio
          ls -la bin/

      - name: Setup KVM
        run: |
          if [ -e /dev/kvm ]; then
            echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
            sudo udevadm control --reload-rules
            sudo udevadm trigger --name-match=kvm
          fi

      - name: Install libvirt and Vagrant
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq libvirt-daemon-system libvirt-dev libvirt-clients qemu-kvm ruby-dev ruby-libvirt build-essential
          sudo systemctl start libvirtd
          sudo usermod -aG libvirt,kvm $USER

          wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt-get update -qq && sudo apt-get install -y -qq vagrant
          vagrant plugin install vagrant-libvirt

      - name: Cache Vagrant box
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.vagrant.d/boxes
          key: vagrant-${{ matrix.vm }}-v1

      - name: Start VM
        working-directory: e2e
        run: sudo -E vagrant up ${{ matrix.vm }} --provider=libvirt

      - name: Sync folders
        working-directory: e2e
        run: |
          echo "=== Getting VM SSH config ==="
          sudo -E vagrant ssh-config ${{ matrix.vm }} 2>&1 | tee /tmp/ssh-config-${{ matrix.vm }} || true
          VM_IP=$(grep HostName /tmp/ssh-config-${{ matrix.vm }} | awk '{print $2}')
          echo "VM IP: $VM_IP"

          echo "=== Waiting for VM to be SSH-ready ==="
          for i in $(seq 1 36); do
            if timeout 2 bash -c "echo >/dev/tcp/$VM_IP/22" 2>/dev/null; then
              echo "Port 22 is open on $VM_IP"
              if sudo -E vagrant ssh ${{ matrix.vm }} -c "echo 'VM ready'" 2>/dev/null; then
                echo "=== VM is SSH-accessible after $((i * 5)) seconds ==="
                break
              fi
            else
              echo "Port 22 not yet open (attempt $i/36)"
            fi

            if [ "$i" = "36" ]; then
              echo "ERROR: VM not SSH-accessible after 180 seconds"
              sudo -E vagrant status ${{ matrix.vm }} || true
              cat /tmp/ssh-config-${{ matrix.vm }} || true
              sudo virsh list --all || true
              exit 1
            fi
            sleep 5
          done

          echo "=== Attempting vagrant rsync ==="
          if sudo -E vagrant rsync ${{ matrix.vm }} 2>&1; then
            echo "=== Rsync succeeded ==="
          else
            echo "=== Rsync failed, using tar-over-ssh fallback ==="
            sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo mkdir -p /setup /bin-local /vagrant && sudo chmod 777 /setup /bin-local /vagrant"
            tar -cv -C .. setup | sudo -E vagrant ssh ${{ matrix.vm }} -c "cd / && sudo tar -xv"
            tar -cv -C .. bin | sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo tar -xv -C /bin-local --strip-components=1"
            tar -cv . | sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo tar -xv -C /vagrant"
            sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo chown -R root:root /setup /bin-local"
          fi

          echo "=== Verifying synced files ==="
          sudo -E vagrant ssh ${{ matrix.vm }} -c "ls -la /setup /bin-local /vagrant"

      - name: Run VM tests
        working-directory: e2e
        run: |
          echo "=== Step 1: Verify synced folders ==="
          sudo -E vagrant ssh ${{ matrix.vm }} -c "ls -la /bin-local/ /setup/ /vagrant/"

          echo "=== Step 2: Check binary format ==="
          sudo -E vagrant ssh ${{ matrix.vm }} -c "file /bin-local/supervizio || true; ls -la /bin-local/supervizio"

          echo "=== Step 3: Copy binary to /usr/local/bin ==="
          sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo mkdir -p /usr/local/bin && sudo cp /bin-local/supervizio /usr/local/bin/ && sudo chmod +x /usr/local/bin/supervizio"

          echo "=== Step 4: Run install script ==="
          sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo chmod +x /setup/*.sh && sudo /setup/install.sh"

          echo "=== Step 5: Check version ==="
          sudo -E vagrant ssh ${{ matrix.vm }} -c "/usr/local/bin/supervizio --version" || true

          echo "=== Step 6: Run test script ==="
          sudo -E vagrant ssh ${{ matrix.vm }} -c "sudo sh -x /vagrant/test-install.sh"

      - name: Cleanup VM
        if: always()
        working-directory: e2e
        run: sudo vagrant destroy ${{ matrix.vm }} -f || true

      - name: Collect logs on failure
        if: failure()
        working-directory: e2e
        run: |
          sudo vagrant status || true
          sudo virsh list --all || true

  # =============================================================================
  # Create Release (only after E2E tests pass)
  # =============================================================================
  release:
    name: Release
    needs: [version, build, packages, e2e-linux, e2e-bsd]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Download all artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          path: artifacts

      - name: Prepare release
        run: |
          mkdir -p release
          cd artifacts
          for dir in */; do
            for file in "$dir"*; do
              [ -f "$file" ] || continue
              filename=$(basename "$file")
              mv "$file" ../release/
              (cd ../release && sha256sum "$filename" >> checksums.txt)
            done
          done
          echo "=== Checksums ===" && cat ../release/checksums.txt

      - name: Generate release notes
        env:
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          cat > release-notes.md << 'EOF'
          ## superviz.io ${{ needs.version.outputs.version }}

          PID1-capable process supervisor for containers and Unix systems.

          ### Platforms

          | OS | amd64 | arm64 | arm | 386 | riscv64 |
          |----|:-----:|:-----:|:---:|:---:|:-------:|
          | Linux | ✅ | ✅ | ✅ | ✅ | ✅ |
          | macOS | ✅ | ✅ | - | - | - |
          | FreeBSD | ✅ | ✅ | ✅ | ✅ | ✅ |
          | OpenBSD | ✅ | ✅ | ✅ | ✅ | - |
          | NetBSD | ✅ | ✅ | ✅ | ✅ | - |
          | DragonFlyBSD | ✅ | - | - | - | - |

          ### E2E Tested

          | Init System | Distribution | Status |
          |-------------|--------------|:------:|
          | systemd | Debian, Fedora | ✅ |
          | OpenRC | Alpine | ✅ |
          | SysVinit | Devuan | ✅ |
          | runit | Alpine | ✅ |
          | BSD rc.d | FreeBSD, OpenBSD, NetBSD, DragonFlyBSD | ✅ |

          ### Linux Packages

          | Format | Distributions | Install Command |
          |--------|---------------|-----------------|
          | `.deb` | Debian, Devuan | `sudo dpkg -i supervizio_*.deb` |
          | `.rpm` | Rocky, RHEL, Fedora | `sudo rpm -i supervizio-*.rpm` |
          | `.apk` | Alpine | `sudo apk add --allow-untrusted supervizio-*.apk` |

          ### Binary Install (all platforms)

          ```bash
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m | sed 's/x86_64/amd64/;s/aarch64/arm64/;s/armv7l/arm/;s/i686/386/')
          curl -fsSL "https://github.com/${{ github.repository }}/releases/download/${{ needs.version.outputs.version }}/supervizio-${OS}-${ARCH}" -o supervizio
          chmod +x supervizio && sudo mv supervizio /usr/local/bin/
          ```

          ### Checksums (SHA256)
          ```
          EOF
          cat release/checksums.txt >> release-notes.md
          echo '```' >> release-notes.md

      - name: Create tag (if needed)
        if: needs.version.outputs.is_new_tag == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ needs.version.outputs.version }}" -m "Release ${{ needs.version.outputs.version }}"
          git push origin "${{ needs.version.outputs.version }}"

      - name: Create Release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2.5.0
        with:
          name: superviz.io ${{ needs.version.outputs.version }}
          tag_name: ${{ needs.version.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: ${{ contains(needs.version.outputs.version, '-') }}
          files: release/*
          token: ${{ secrets.GITHUB_TOKEN }}

  # =============================================================================
  # Cleanup on E2E Failure
  # =============================================================================
  # If E2E tests fail and a tag was created, delete it to prevent
  # incomplete releases.
  # =============================================================================
  cleanup-on-failure:
    name: Cleanup Failed Release
    needs: [version, e2e-linux, e2e-bsd]
    if: failure() && needs.version.outputs.is_new_tag == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
        with:
          fetch-depth: 0

      - name: Delete tag if E2E failed
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "E2E tests failed. Checking if tag $VERSION exists..."

          # Check if tag exists remotely
          if git ls-remote --tags origin | grep -q "refs/tags/$VERSION"; then
            echo "Tag $VERSION exists. Deleting..."
            git push origin --delete "$VERSION" || echo "Tag deletion failed (may not exist yet)"
          else
            echo "Tag $VERSION does not exist remotely. Nothing to delete."
          fi

      - name: Delete release if exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Checking if release $VERSION exists..."

          # Get release ID if it exists
          RELEASE_ID=$(gh release view "$VERSION" --json id --jq '.id' 2>/dev/null || echo "")

          if [ -n "$RELEASE_ID" ]; then
            echo "Release $VERSION exists. Deleting..."
            gh release delete "$VERSION" --yes || echo "Release deletion failed"
          else
            echo "Release $VERSION does not exist. Nothing to delete."
          fi
