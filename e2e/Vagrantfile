# -*- mode: ruby -*-
# vi: set ft=ruby :
# =============================================================================
# supervizio E2E Testing Vagrantfile
# =============================================================================
# Full matrix of init systems and platforms:
#
# Linux (systemd):
#   - debian13: Debian 13 (trixie) - primary (.deb)
#   - fedora: Fedora 38 - RPM/dnf (.rpm)
#
# Linux (OpenRC):
#   - alpine: Alpine 3.21 (.apk)
#
# Linux (SysVinit):
#   - devuan: Devuan 6 (excalibur) - Debian without systemd (.deb)
#
# Linux (runit):
#   - alpine-runit: Alpine 3.21 with runit (.apk)
#
# BSD (rc.d):
#   - freebsd: FreeBSD 14 (pkg)
#   - openbsd: OpenBSD 7 (pkg)
#   - netbsd: NetBSD 9 (pkgin)
#
# Note: Vagrant boxes may lag behind latest versions. Using latest available.
#
# Providers:
#   - libvirt: Linux CI (KVM acceleration)
#   - qemu: macOS (HVF or TCG)
# =============================================================================

# Detect Homebrew path for macOS (ARM64 vs Intel)
def homebrew_prefix
  if RUBY_PLATFORM.include?("arm64") || `uname -m`.strip == "arm64"
    "/opt/homebrew"
  else
    "/usr/local"
  end
end

# Detect if running in CI (GitHub Actions does NOT support HVF)
def ci_mode?
  ENV['CI'] == 'true' || ENV['GITHUB_ACTIONS'] == 'true'
end

# Helper to configure rsync synced folders for Linux VMs
# Linux boxes have rsync pre-installed or install it early enough
def configure_linux_synced_folders(v)
  v.vm.synced_folder "../setup", "/setup", type: "rsync"
  # Always configure bin folder - rsync will handle missing source gracefully
  # CI creates bin/ before vagrant up, so this is safe
  v.vm.synced_folder "../bin", "/bin-local", type: "rsync", create: true
  v.vm.synced_folder "../src", "/vagrant/src", type: "rsync"
  v.vm.synced_folder ".", "/vagrant", type: "rsync"
end

# Helper to disable synced folders for BSD VMs
# BSD boxes don't have rsync pre-installed; CI uses tar-over-SSH instead
def configure_bsd_synced_folders(v)
  v.vm.synced_folder ".", "/vagrant", disabled: true
end

Vagrant.configure("2") do |config|
  # ===========================================================================
  # QEMU Provider (macOS)
  # ===========================================================================
  config.vm.provider "qemu" do |qe|
    qe.memory = "2048"
    qe.smp = "2"
    qe.qemu_dir = "#{homebrew_prefix}/share/qemu"
    qe.ssh_port = 50022

    # Detect architecture
    is_arm = RUBY_PLATFORM.include?("arm64") || `uname -m`.strip == "arm64"

    if ci_mode?
      # CI mode: Use TCG (software emulation) - HVF not available on GitHub Actions
      qe.net_device = "virtio-net-pci"
      qe.extra_qemu_args = %w(-accel tcg,thread=multi)

      if is_arm
        qe.arch = "aarch64"
        qe.machine = "virt,highmem=on"
        qe.cpu = "cortex-a72"
      else
        qe.arch = "x86_64"
        qe.machine = "q35"
        qe.cpu = "max"
      end
    else
      # Local mode: Use HVF for native performance
      qe.machine = "virt,accel=hvf,highmem=on"
      qe.cpu = "cortex-a72" if is_arm
    end
  end

  # ===========================================================================
  # Libvirt Provider (Linux CI - AMD64 and ARM64)
  # ===========================================================================
  config.vm.provider "libvirt" do |lv|
    lv.memory = 2048
    lv.cpus = 2

    # Increase timeouts for software emulation (QEMU TCG is slow)
    lv.qemu_use_session = false
    # Wait up to 10 minutes for VM to boot and get an IP (default is 2 seconds!)
    lv.wait_timeout = 600

    # Detect ARM64 architecture
    is_arm = RUBY_PLATFORM.include?("aarch64") || `uname -m`.strip == "aarch64"

    # Check if KVM is available (CI runners may not have it)
    kvm_available = File.exist?('/dev/kvm') && File.readable?('/dev/kvm')

    if kvm_available
      lv.driver = "kvm"
      lv.cpu_mode = "host-passthrough" if is_arm
    else
      # Use QEMU TCG (software emulation) when KVM not available
      lv.driver = "qemu"
      lv.cpu_mode = "custom"
      lv.cpu_model = is_arm ? "cortex-a72" : "qemu64"
    end

    # ARM64-specific configuration
    # AAVMF is the ARM equivalent of OVMF (x86 UEFI)
    if is_arm
      lv.machine_type = "virt"

      # ARM64 doesn't support PS/2 - use virtio input devices
      # Clear default inputs and add virtio ones
      lv.inputs = []
      lv.input :type => "tablet", :bus => "virtio"

      # Video type for ARM64 (virtio instead of cirrus)
      lv.video_type = "virtio"

      # UEFI firmware paths (varies by distro/package)
      firmware_paths = [
        "/usr/share/AAVMF/AAVMF_CODE.fd",           # Ubuntu qemu-efi-aarch64
        "/usr/share/qemu-efi-aarch64/QEMU_EFI.fd",  # Alternative Ubuntu path
        "/usr/share/edk2/aarch64/QEMU_EFI.fd"       # Fedora/RHEL edk2
      ]

      # Find and set loader (UEFI firmware)
      loader_found = firmware_paths.find { |p| File.exist?(p) }
      if loader_found
        lv.loader = loader_found
      else
        # Fallback: set primary path anyway (clearer error if missing)
        lv.loader = "/usr/share/AAVMF/AAVMF_CODE.fd"
        STDERR.puts "WARNING: No UEFI firmware found at: #{firmware_paths.join(', ')}"
      end

      # NVRAM template paths for UEFI variable storage
      nvram_paths = [
        "/usr/share/AAVMF/AAVMF_VARS.fd",                    # Ubuntu qemu-efi-aarch64
        "/usr/share/qemu-efi-aarch64/vars-template-pflash.raw",
        "/usr/share/edk2/aarch64/vars-template-pflash.raw"   # Fedora/RHEL
      ]

      # Find and set NVRAM template
      nvram_found = nvram_paths.find { |p| File.exist?(p) }
      lv.nvram = nvram_found if nvram_found
    end
  end

  # ===========================================================================
  # LINUX: systemd
  # ===========================================================================

  # Debian 13 (trixie) - Primary test VM
  config.vm.define "debian13", primary: true do |v|
    v.vm.box = "generic/debian12"  # Use debian12 box until debian13 is available
    v.vm.hostname = "e2e-debian13"
    configure_linux_synced_folders(v)
    v.vm.provision "shell", inline: "apt-get update -qq && apt-get install -y -qq curl jq rsync"
  end

  # Fedora 39 - RPM/dnf + systemd (39 has ARM64 libvirt boxes, 38 does not)
  config.vm.define "fedora", autostart: false do |v|
    v.vm.box = "generic/fedora39"
    v.vm.hostname = "e2e-fedora"
    configure_linux_synced_folders(v)
    v.vm.provision "shell", inline: <<-SHELL
      # Update package cache and install rsync
      dnf makecache --refresh || true
      dnf install -y curl jq rsync
      # Verify rsync is installed
      which rsync && rsync --version | head -1
    SHELL
  end

  # ===========================================================================
  # LINUX: OpenRC
  # ===========================================================================

  # Alpine 3.19 - 3.20 box not yet available
  config.vm.define "alpine", autostart: false do |v|
    v.vm.box = "generic/alpine319"
    v.vm.hostname = "e2e-alpine"
    configure_linux_synced_folders(v)
    v.vm.provision "shell", inline: "apk update && apk add curl jq rsync"
  end

  # ===========================================================================
  # LINUX: SysVinit
  # ===========================================================================

  # Devuan 5 (daedalus) - Debian without systemd
  config.vm.define "devuan", autostart: false do |v|
    v.vm.box = "generic/devuan4"  # Use devuan4 (chimaera) until devuan5 box available
    v.vm.hostname = "e2e-devuan"
    configure_linux_synced_folders(v)
    v.vm.provision "shell", inline: "apt-get update -qq && apt-get install -y -qq curl jq rsync"
  end

  # ===========================================================================
  # LINUX: runit
  # ===========================================================================

  # Alpine 3.19 with runit (instead of OpenRC)
  # Uses same box as alpine but replaces OpenRC with runit
  config.vm.define "alpine-runit", autostart: false do |v|
    v.vm.box = "generic/alpine319"
    v.vm.hostname = "e2e-alpine-runit"
    configure_linux_synced_folders(v)
    v.vm.provision "shell", inline: <<-SHELL
      # Enable community repo for runit
      sed -i 's/#.*community/community/' /etc/apk/repositories
      apk update

      # Remove OpenRC and install runit
      apk del openrc --force-broken-world 2>/dev/null || true
      apk add curl jq rsync runit

      # Create runit service directories
      mkdir -p /etc/sv /var/service

      # Verify runit is available (OpenRC removal is best-effort)
      which runsvdir && echo "runit installed successfully"
      # Note: rc-service may remain as dangling binary, check service manager instead
      if [ -x /usr/bin/runsvdir ]; then
        echo "runit service manager ready"
      else
        echo "ERROR: runit not properly installed" && exit 1
      fi
    SHELL
  end

  # ===========================================================================
  # BSD: rc.d (FreeBSD style)
  # ===========================================================================
  # NOTE: BSD VMs use disabled synced_folders because:
  # 1. BSD boxes don't have rsync pre-installed
  # 2. rsync is installed during provisioning (after synced_folders would run)
  # 3. CI workflow syncs files via tar-over-SSH after provisioning completes
  # ===========================================================================

  # FreeBSD 14
  config.vm.define "freebsd", autostart: false do |v|
    v.vm.box = "generic/freebsd14"
    v.vm.hostname = "e2e-freebsd"
    configure_bsd_synced_folders(v)
    v.vm.provision "shell", inline: <<-SHELL
      pkg install -y curl jq rsync rust go
      # Verify installations
      rustc --version && cargo --version && go version
    SHELL
  end

  # OpenBSD 7.x
  config.vm.define "openbsd", autostart: false do |v|
    v.vm.box = "generic/openbsd7"
    v.vm.hostname = "e2e-openbsd"
    configure_bsd_synced_folders(v)
    v.vm.provision "shell", inline: <<-SHELL
      # Install packages (rsync-- means rsync with no flavor suffix)
      pkg_add curl jq rsync rust go
      # Verify installations
      rustc --version && cargo --version && go version
    SHELL
  end

  # NetBSD 9 (netbsd10 box not yet available on Vagrant Cloud)
  config.vm.define "netbsd", autostart: false do |v|
    v.vm.box = "generic/netbsd9"
    v.vm.hostname = "e2e-netbsd"
    configure_bsd_synced_folders(v)
    v.vm.provision "shell", inline: <<-SHELL
      # Update pkgin database and install packages
      pkgin -y update || true
      pkgin -y install curl jq rsync rust go
      # Verify installations
      rustc --version && cargo --version && go version
    SHELL
  end

end
